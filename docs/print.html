<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js dark">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>master-leetcode</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "dark";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('dark')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="empty.html"><strong aria-hidden="true">1.</strong> C</a></li><li class="expanded "><a href="empty.html"><strong aria-hidden="true">2.</strong> Java</a></li><li class="expanded "><a href="empty.html"><strong aria-hidden="true">3.</strong> Koltin</a></li><li class="expanded "><a href="empty.html"><strong aria-hidden="true">4.</strong> Python</a></li><li class="expanded "><a href="empty.html"><strong aria-hidden="true">5.</strong> Rust</a></li><li><ol class="section"><li class="expanded "><a href="rust/round_1.html"><strong aria-hidden="true">5.1.</strong> Round 1</a></li><li><ol class="section"><li class="expanded "><a href="rust/round_1_linked_list.html"><strong aria-hidden="true">5.1.1.</strong> Linked-List</a></li><li class="expanded "><a href="rust/round_1_tree.html"><strong aria-hidden="true">5.1.2.</strong> Tree</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">master-leetcode</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>waiting for ur commit ü¶Ä</p>
<p>waiting for ur commit ü¶Ä</p>
<p>waiting for ur commit ü¶Ä</p>
<p>waiting for ur commit ü¶Ä</p>
<p>waiting for ur commit ü¶Ä</p>
<h1><a class="header" href="#round-1" id="round-1">Round 1</a></h1>
<h2><a class="header" href="#1-boxt-and-rc" id="1-boxt-and-rc">1. <code>Box&lt;T&gt;</code> and <code>Rc</code></a></h2>
<p><code>Box&lt;T&gt;</code>, casually referred to as a 'box', provides the simplest form of heap allocation in Rust. Boxes provide ownership for this allocation, and drop their contents when they go out of scope.</p>
<p><strong>What's the difference between <code>Rc&lt;T&gt;</code> and <code>Box&lt;T&gt;</code>?</strong></p>
<p><code>Rc</code> provides shared ownership so by default its contents can't be mutated, while <code>Box</code> provides exclusive ownership and thus mutation is allowed:</p>
<pre><pre class="playpen"><code class="language-rust">use std::rc::Rc;

fn main() {
    let mut a = Box::new(1);
    let mut b = Rc::new(1);

    *a = 2; // works
    *b = 2; // doesn't
}
</code></pre></pre>
<blockquote>
<p>Checkout this question on <a href="https://stackoverflow.com/questions/49377231/when-to-use-rc-vs-box">stackoverflow</a></p>
</blockquote>
<h2><a class="header" href="#2-cell-and-refcell" id="2-cell-and-refcell">2. <code>Cell</code> and <code>RefCell</code></a></h2>
<p>Values of the <code>Cell&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code> types may be mutated through shared references (i.e. the common &amp;T type), whereas most Rust types can only be mutated through unique <code>(&amp;mut T)</code> references. We say that <code>Cell&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code> provide <strong>'interior mutability'</strong>, in contrast with typical Rust types that exhibit <strong>'inherited mutability'</strong>.</p>
<p>Cell types come in two flavors: <code>Cell&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>. <code>Cell&lt;T&gt;</code> implements interior mutability by moving values in and out of the <code>Cell&lt;T&gt;</code>. To use references instead of values, one must use the <code>RefCell&lt;T&gt;</code> type, acquiring a write lock before mutating. <code>Cell&lt;T&gt;</code> provides methods to retrieve and change the current interior value:</p>
<ul>
<li>For types that implement <code>Copy</code>, the get method retrieves the current interior value.</li>
<li>For types that implement <code>Default</code>, the <code>take</code> method replaces the current interior value with <code>Default::default()</code> and returns the replaced value.</li>
<li>For all types, the <code>replace</code> method replaces the current interior value and returns the replaced value and the <code>into_inner</code> method consumes the <code>Cell&lt;T&gt;</code> and returns the interior value. Additionally, the <code>set</code> method replaces the interior value, dropping the replaced value.</li>
</ul>
<p><code>RefCell&lt;T&gt;</code> uses Rust's lifetimes to implement <code>'dynamic borrowing'</code>, a process whereby one can claim temporary, exclusive, mutable access to the inner value. Borrows for <code>RefCell&lt;T&gt;</code>s are tracked <code>'at runtime'</code>, unlike Rust's native reference types which are entirely tracked statically, at compile time. Because <code>RefCell&lt;T&gt;</code> borrows are dynamic it is possible to attempt to borrow a value that is already mutably borrowed; when this happens it results in thread panic.</p>
<h3><a class="header" href="#when-to-choose-interior-mutability" id="when-to-choose-interior-mutability">When to choose interior mutability?</a></h3>
<p>The more common inherited mutability, where one must have unique access to mutate a value, is one of the key language elements that enables Rust to reason strongly about pointer aliasing, statically preventing crash bugs. Because of that, inherited mutability is preferred, and interior mutability is something of a last resort. Since cell types enable mutation where it would otherwise be disallowed though, there are occasions when interior mutability might be appropriate, or even must be used, e.g.</p>
<ul>
<li>Introducing mutability 'inside' of something immutable</li>
<li>Implementation details of logically-immutable methods.</li>
<li>Mutating implementations of <code>Clone</code>.</li>
</ul>
<h2><a class="header" href="#3-asref-and-borrow" id="3-asref-and-borrow">3. <code>AsRef</code> and <code>Borrow</code></a></h2>
<p><code>AsRef</code> is similar to <code>AsMut</code> which is used for converting between mutable references. If you need to do a costly conversion it is better to implement From with type &amp;T or write a custom function.</p>
<p><strong>AsRef has the same signature as Borrow, but Borrow is different in few aspects:</strong></p>
<ul>
<li>
<p>Unlike AsRef, Borrow has a blanket impl for any T, and can be used to accept either a reference or a value.</p>
</li>
<li>
<p>Borrow also requires that Hash, Eq and Ord for borrowed value are equivalent to those of the owned value. For this reason, if you want to borrow only a single field of a struct you can implement AsRef, but not Borrow.</p>
</li>
</ul>
<p>Note: This trait must not fail. If the conversion can fail, use a dedicated method which returns an Option<T> or a Result&lt;T, E&gt;.</p>
<h3><a class="header" href="#example" id="example">Example</a></h3>
<p>By creating a generic function that takes an <code>AsRef&lt;str&gt;</code> we express that we want to accept all references that can be converted to <code>&amp;str</code> as an argument. Since both String and <code>&amp;str</code> implement <code>AsRef&lt;str&gt;</code> we can accept both as input argument.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn is_hello&lt;T: AsRef&lt;str&gt;&gt;(s: T) {
   assert_eq!(&quot;hello&quot;, s.as_ref());
}

let s = &quot;hello&quot;;
is_hello(s);

let s = &quot;hello&quot;.to_string();
is_hello(s);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#4-clonecopy-and-toowned" id="4-clonecopy-and-toowned">4. <code>Clone</code>„ÄÅ<code>Copy</code> and <code>ToOwned</code></a></h2>
<p>Differs from <code>Copy</code> in that <code>Copy</code> is implicit and extremely inexpensive, while Clone is always explicit and may or may not be expensive. In order to enforce these characteristics, Rust does not allow you to reimplement Copy, but you may reimplement Clone and run arbitrary code.</p>
<p><code>Copy</code> are the types whose values can be duplicated simply by copying bits:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// We can derive a `Copy` implementation. `Clone` is also required, as it's
// a supertrait of `Copy`.
#[derive(Debug, Copy, Clone)]
struct Foo;

let x = Foo;

let y = x;

// `y` is a copy of `x`

println!(&quot;{:?}&quot;, x); // A-OK!
<span class="boring">}
</span></code></pre></pre>
<p>Both a copy and a move can result in bits being copied in memory, although this is sometimes optimized away.</p>
<p><code>Clone</code> is a supertrait of <code>Copy</code>, so everything which is <code>Copy</code> must also implement <code>Clone</code>. If a type is <code>Copy</code> then its <code>Clone</code> implementation only needs to return *self (see the example above).</p>
<p><code>ToOnwed</code> are some types make it possible to go from borrowed to owned, usually by implementing the Clone trait. But Clone works only for going from &amp;T to T. The ToOwned trait generalizes Clone to construct owned data from any borrow of a given type.</p>
<h2><a class="header" href="#5-zero-copy" id="5-zero-copy">5. Zero Copy</a></h2>
<h3><a class="header" href="#stdmemswap" id="stdmemswap"><code>std::mem::swap</code></a></h3>
<p>Swaps the values at two mutable locations, without deinitializing either one.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::mem;

let mut x = 5;
let mut y = 42;

mem::swap(&amp;mut x, &amp;mut y);

assert_eq!(42, x);
assert_eq!(5, y);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#stdmemreplace" id="stdmemreplace"><code>std::mem::replace</code></a></h3>
<p>Moves src into the referenced dest, returning the previous dest value.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::mem;

let mut v: Vec&lt;i32&gt; = vec![1, 2];

let old_v = mem::replace(&amp;mut v, vec![3, 4, 5]);
assert_eq!(vec![1, 2], old_v);
assert_eq!(vec![3, 4, 5], v);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#stdoptionoptiontake" id="stdoptionoptiontake"><code>std::option::Option::take</code></a></h3>
<p>Takes the value out of the option, leaving a None in its place.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut x = Some(2);
let y = x.take();
assert_eq!(x, None);
assert_eq!(y, Some(2));

let mut x: Option&lt;u32&gt; = None;
let y = x.take();
assert_eq!(x, None);
assert_eq!(y, None);
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#linked-list" id="linked-list">Linked-List</a></h1>
<h2><a class="header" href="#21merge-two-sorted-lists" id="21merge-two-sorted-lists">21.merge-two-sorted-lists</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn merge_two_lists(
        mut l1: Option&lt;Box&lt;ListNode&gt;&gt;,
        mut l2: Option&lt;Box&lt;ListNode&gt;&gt;,
    ) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        use std::mem;
		
        let mut pa = &amp;mut l1;
        let pb = &amp;mut l2;

        // Merge l2 to l1
        //
        // Current List -&gt;  &quot;**&gt;&gt;&gt;&quot;
        // Dynamic List -&gt;  &quot;&gt;&gt;&gt;&gt;&gt;&quot;
        while pb.is_some() {
            if pa.is_none() || pa.as_ref()?.val &gt; pb.as_ref()?.val {
                mem::swap(pa, pb);
            } else {
                pa = &amp;mut pa.as_mut()?.next;
            }
        }

        l1
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#83remove-duplicate-from-sorted-list" id="83remove-duplicate-from-sorted-list">83.remove-duplicate-from-sorted-list</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn delete_duplicates(
	  mut head: Option&lt;Box&lt;ListNode&gt;&gt;
	) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        let mut ptr = &amp;mut head;
        let mut _nxt: Option&lt;Box&lt;ListNode&gt;&gt; = None;

        while ptr.is_some() &amp;&amp; ptr.as_ref()?.next.is_some() {
            if ptr.as_ref()?.val == ptr.as_ref()?.next.as_ref()?.val {
                // make sure not using next.next directly
                _nxt = ptr.as_mut()?.next.take();
                ptr.as_mut()?.next = _nxt.as_mut()?.next.take();
            }
            ptr = &amp;mut ptr.as_mut()?.next;
        }

        head
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#141-linked-list-cycle" id="141-linked-list-cycle">141. linked-list-cycle</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn has_circle(mut head: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;bool&gt; {
        let mut slow = &amp;mut head;
        let mut fast = slow.clone();

        while slow.is_some() &amp;&amp; slow.as_ref()?.next.as_ref()?.next.is_some() {
            slow = &amp;mut slow.as_mut()?.next;
            fast = fast.unwrap().next.unwrap().next;
			
            // if two pointers meet, cycle exists.
            if slow.as_ref()? == fast.as_ref()? {
                return Some(true);
            }
        }

        return None;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#160-intersection-of-two-linked-list" id="160-intersection-of-two-linked-list">160. intersection-of-two-linked-list</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn get_intersection(
        mut l1: Option&lt;Box&lt;ListNode&gt;&gt;,
        mut l2: Option&lt;Box&lt;ListNode&gt;&gt;,
    ) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        let mut pa = &amp;mut l1.clone();
        let mut pb = &amp;mut l2.clone();

        while pa.is_some() &amp;&amp; pb.is_some() {
		    // The end of both two is the intersection.
            if pa == pb {
                return pa.to_owned();
            }

            if pa.as_ref()?.next.is_some() {
                pa = &amp;mut pa.as_mut()?.next;
            } else {
                pa = &amp;mut l2;
            }

            if pb.as_ref()?.next.is_some() {
                pb = &amp;mut pb.as_mut()?.next;
            } else {
                pb = &amp;mut l1;
            }
        }

        None
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#203-remove-linked-list-element" id="203-remove-linked-list-element">203 remove-linked-list-element</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn remove_elements(
	  mut head: Option&lt;Box&lt;ListNode&gt;&gt;, val: i32
	) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        let mut ptr = &amp;mut head;

        while ptr.is_some() {
            // replace current value in memory
            if ptr.as_ref()?.val == val {
                // *ptr = std::mem::replace(&amp;mut ptr.as_mut()?.next, None);
                *ptr = ptr.as_mut()?.next.take();
            } else {
                ptr = &amp;mut ptr.as_mut()?.next;
            }
        }

        head
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#206-reverse-linked-list" id="206-reverse-linked-list">206. reverse-linked-list</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn reverse_list(mut head: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        let mut ret = None;
        let mut _nxt = None;

        while head.is_some() {
            _nxt = head.as_mut()?.next.take();
            head.as_mut()?.next = ret;
            ret = head;

            // Reverse
            //
            // Old ListNode: &quot;***&gt;&gt;&quot;
            // Ret ListNode: &quot;&gt;&gt;&gt;&quot;
            head = _nxt;
        }

        ret
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#234-palindrome-linked-list" id="234-palindrome-linked-list">234. palindrome-linked-list</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn is_palindrome(mut head: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; bool {
        if head.is_none() {
            return true;
        }

        let mut rev: Option&lt;Box&lt;ListNode&gt;&gt; = None;
        let mut _nxt: Option&lt;Box&lt;ListNode&gt;&gt; = None;
        
		// Just like 206, half to half
        while head.is_some() {
            if rev == head || rev == head.as_ref().unwrap().next {
                return true;
            }

            _nxt = head.as_mut().unwrap().next.take();
            head.as_mut().unwrap().next = rev;
            rev = head;
            head = _nxt;
        }

        false
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#237delete-node-in-a-linked-list" id="237delete-node-in-a-linked-list">237.delete-node-in-a-linked-list</a></h2>
<blockquote>
<p>Same as 203</p>
</blockquote>
<h2><a class="header" href="#876middle-of-the-linked-list" id="876middle-of-the-linked-list">876.middle-of-the-linked-list</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn middle_node(mut head: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        let mut ptr = head.clone();

        while ptr.is_some() &amp;&amp; ptr.as_ref()?.next.is_some() {
            ptr = ptr.unwrap().next.unwrap().next;
            head = head.unwrap().next;
        }

        head
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#1290convert-binary-number-in-a-linked-list-to-integer" id="1290convert-binary-number-in-a-linked-list-to-integer">1290.convert-binary-number-in-a-linked-list-to-integer</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn get_decimal_value(mut head: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; i32 {
        let mut ret = 0;
        while head.is_some() {
            ret = (ret &lt;&lt; 1) | head.as_ref().unwrap().val;
            head = head.unwrap().next;
        }

        ret
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#tree" id="tree">Tree</a></h1>
<h2><a class="header" href="#100same-tree" id="100same-tree">100.same-tree</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn is_same_tree(
        p: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,
        q: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,
    ) -&gt; bool {
        Self::eq(&amp;p, &amp;q)
    }

    fn eq(
	  p: &amp;Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, 
	  q: &amp;Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;
	) -&gt; bool {
        match (p, q) {
            (Some(p), Some(q)) =&gt; {
                let (p, q) = (p.borrow(), q.borrow());
                p.val == q.val 
				  &amp;&amp; Solution::eq(&amp;p.left, &amp;q.left) 
				  &amp;&amp; Solution::eq(&amp;p.right, &amp;q.right)
            }
            (None, None) =&gt; true,
            _ =&gt; false,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#101symmetric-tree" id="101symmetric-tree">101.symmetric-tree</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;
use std::rc::Rc;
impl Solution {
    pub fn is_symmetric(root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; bool {
        if let Some(r) = root {
            let r = r.borrow();
            return Self::mirror(&amp;r.left, &amp;r.right);
        }

        true
    }

    pub fn mirror(
	  t1: &amp;Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, 
	  t2: &amp;Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;
	) -&gt; bool {
        match (t1, t2) {
            (&amp;None, &amp;None) =&gt; true,
            (Some(n1), Some(n2)) =&gt; {
                let (n1, n2) = (n1.borrow(), n2.borrow());

                n1.val == n2.val
                    &amp;&amp; Self::mirror(&amp;n1.left, &amp;n2.right)
                    &amp;&amp; Self::mirror(&amp;n2.left, &amp;n1.right)
            }
            _ =&gt; false,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#104maximum-depth-of-binary-tree" id="104maximum-depth-of-binary-tree">104.maximum-depth-of-binary-tree</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;
use std::rc::Rc;
impl Solution {
    pub fn max_depth(root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; i32 {
        Self::ruler(&amp;root, 0)
    }

    fn ruler(t: &amp;Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, d: i32) -&gt; i32 {
        if let Some(t) = t {
            let t = t.borrow();
            return std::cmp::max(
			  Self::ruler(&amp;t.left, d + 1), 
			  Self::ruler(&amp;t.right, d + 1)
		    );
        }

        d
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#107binary-tree-level-order-traversal-ii" id="107binary-tree-level-order-traversal-ii">107.binary-tree-level-order-traversal-ii</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn level_order_bottom(root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {
        let mut res: Vec&lt;Vec&lt;i32&gt;&gt; = Vec::new();
        Self::bu(0, &amp;root, res.as_mut());
        res.reverse();
        res
    }

    fn bu(d: usize, r: &amp;Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, res: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;) {
        if let Some(r) = r {
            if res.len() == d {
                res.push(Vec::new());
            }

            res[d].push(r.borrow().val);
            Self::bu(d + 1, &amp;r.borrow().left, res);
            Self::bu(d + 1, &amp;r.borrow().right, res);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#108convert-sorted-array-to-binary-earch-tree" id="108convert-sorted-array-to-binary-earch-tree">108.convert-sorted-array-to-binary-earch-tree</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;
use std::rc::Rc;
impl Solution {
    pub fn sorted_array_to_bst(nums: Vec&lt;i32&gt;) -&gt; Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt; {
        Self::h(nums)
    }

    pub fn h(v: Vec&lt;i32&gt;) -&gt; Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt; {
        if v.len() == 0 {
            return None;
        }

        let mid = v.len() / 2;
        let root = Rc::new(RefCell::new(TreeNode::new(v[mid])));
        root.borrow_mut().left = Self::h(v[..mid].to_vec());
        root.borrow_mut().right = Self::h(v[mid + 1..].to_vec());
        Some(root)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#110balanced-binary-tree" id="110balanced-binary-tree">110.balanced-binary-tree</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;
use std::rc::Rc;
impl Solution {
    pub fn is_balanced(root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; bool {
        Self::bd(&amp;root).is_ok()
    }

    fn bd(r: &amp;Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; Result&lt;i32, ()&gt; {
        if let Some(r) = r {
            let lt = Self::bd(&amp;r.borrow().left)?;
            let rt = Self::bd(&amp;r.borrow().right)?;
            if (lt - rt).abs() &gt; 1 {
                Err(())
            } else {
                Ok(1 + std::cmp::max(lt, rt))
            }
        } else {
            Ok(0)
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#111minmum-depth-of-binary-tree" id="111minmum-depth-of-binary-tree">111.minmum-depth-of-binary-tree</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn min_depth(root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; i32 {
        match root {
            Some(r) =&gt; Self::h(&amp;Some(r)),
            None =&gt; 0,
        }
    }

    fn h(r: &amp;Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; i32 {
        if let Some(r) = r {
            let lt = Self::h(&amp;r.borrow().left);
            let rt = Self::h(&amp;r.borrow().right);
            if lt == 0 || rt == 0 {
                1 + lt + rt
            } else {
                std::cmp::min(lt, rt) + 1
            }
        } else {
            0
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#112path-sum" id="112path-sum">112.path-sum</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn has_path_sum(root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, sum: i32) -&gt; bool {
        Self::h(&amp;root, sum)
    }

    fn h(r: &amp;Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, sum: i32) -&gt; bool {
        if let Some(r) = r {
            let r = r.borrow();
            let (lt, rt, val) = (&amp;r.left, &amp;r.right, r.val);
            match (lt, rt) {
                (None, None) =&gt; sum == val,
                _ =&gt; Self::h(&amp;lt, sum - val) || Self::h(&amp;rt, sum - val),
            }
        } else {
            false
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#226invert-binary-tree" id="226invert-binary-tree">226.invert-binary-tree</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn invert_tree(
	  mut root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;
	) -&gt; Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt; {
        Self::h(&amp;mut root);
        root
    }

    fn h(r: &amp;mut Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) {
        if let Some(r) = r {
            let mut r = r.borrow_mut();
            Self::h(&amp;mut r.left);
            Self::h(&amp;mut r.right);

            let lt = std::mem::replace(&amp;mut r.left, None);
            let rt = std::mem::replace(&amp;mut r.right, lt);
            std::mem::replace(&amp;mut r.left, rt);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#235lowest-common-ancestor-of-a-binary-search-tree" id="235lowest-common-ancestor-of-a-binary-search-tree">235.lowest-common-ancestor-of-a-binary-search-tree</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    fn lca(
        root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,
        p: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,
        q: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,
    ) -&gt; Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt; {
        if root.is_none() || p.is_none() || q.is_none() {
            return None;
        }

        // lca should not be none
        let (mut root, p, q) = (root.unwrap(), p.unwrap(), q.unwrap());
        while (root.val - p.val) * (root.val - q.val) &gt; 0 {
            if root == None {
                return None;
            }

            if p.val &gt; root.val {
                root = root.right.unwrap_or(None);
            } else {
                root = root.left.unwrap_or(None);
            }
        }
        root
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#257binary-tree-paths" id="257binary-tree-paths">257.binary-tree-paths</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn binary_tree_paths(root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; Vec&lt;String&gt; {
        let mut res: Vec&lt;String&gt; = Vec::new();
        Self::h(&amp;root, &quot;&quot;, &amp;mut res);
        res
    }

    fn h(t: &amp;Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, mut p: &amp;str, mut r: &amp;mut Vec&lt;String&gt;) {
        if let Some(t) = t {
            let t = t.borrow();
            let val = t.val.to_string();
            let cp = if p.len() == 0 {
                val
            } else {
                p.clone().to_owned() + &quot;-&gt;&quot; + &amp;val
            };

            if t.left.is_none() &amp;&amp; t.right.is_none() {
                r.push(cp);
            } else {
                Self::h(&amp;t.left, &amp;cp, r);
                Self::h(&amp;t.right, &amp;cp, r);
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#404sum-of-left-leaves" id="404sum-of-left-leaves">404.sum-of-left-leaves</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn sum_of_left_leaves(root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; i32 {
        let mut sum = 0;
        Self::h(&amp;root, &amp;mut sum);
        sum
    }

    fn h(r: &amp;Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, s: &amp;mut i32) {
        if let Some(r) = r {
            let r = r.borrow();

            // add
            if let Some(l) = &amp;r.left {
                let l = l.borrow();
                if l.left.is_none() &amp;&amp; l.right.is_none() {
                    *s += l.val;
                }
            }

            // rescursion
            Self::h(&amp;r.left, s);
            Self::h(&amp;r.right, s);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#437path-sum-iii" id="437path-sum-iii">437.path-sum-iii</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn path_sum(root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, sum: i32) -&gt; i32 {
        let mut res = 0;
        Self::h(&amp;mut res, sum, &amp;root);
        if let Some(r) = root {
            let r = r.borrow();
            res += Self::path_sum(r.left.clone(), sum);
            res += Self::path_sum(r.right.clone(), sum);
        }
        res
    }

    fn h(r: &amp;mut i32, s: i32, t: &amp;Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) {
        if let Some(t) = t {
            let t = t.borrow();
            if t.val == s {
                *r += 1;
            }

            Self::h(r, s - t.val, &amp;t.left);
            Self::h(r, s - t.val, &amp;t.right);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#501find-mode-in-binary-search-tree" id="501find-mode-in-binary-search-tree">501.find-mode-in-binary-search-tree</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn find_mode(root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; Vec&lt;i32&gt; {
        let mut counter: HashMap&lt;i32, i32&gt; = HashMap::new();
        let mut rth = vec![];
        Self::h(&amp;root, &amp;mut counter);

        // !important
        if counter.is_empty() {
            return rth;
        }

        let max = *counter.values().max().unwrap();
        for (&amp;k, &amp;v) in counter.iter() {
            if v == max {
                rth.push(k);
            }
        }
        rth
    }

    fn h(r: &amp;Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, counter: &amp;mut HashMap&lt;i32, i32&gt;) {
        if let Some(r) = r {
            let r = r.borrow();
            let count = counter.entry(r.val).or_insert(0);
            *count += 1;
            Self::h(&amp;r.left, counter);
            Self::h(&amp;r.right, counter);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#530minimum-absolute-difference-in-bst" id="530minimum-absolute-difference-in-bst">530.minimum-absolute-difference-in-bst</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn get_minimum_difference(root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; i32 {
        Self::h(&amp;root, MIN, MAX).1
    }

    fn h(r: &amp;Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, last: i32, res: i32) -&gt; (i32, i32) {
        if let Some(r) = r {
            let r = r.borrow();
            let (mut last, mut res) = Self::h(&amp;r.left.clone(), last, res);
            res = res.min(r.val.saturating_sub(last));
            last = r.val;
            return Self::h(&amp;r.right.clone(), last, res);
        }
        return (last, res);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#538convert-bst-to-greater-tree" id="538convert-bst-to-greater-tree">538.convert-bst-to-greater-tree</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn convert_bst(
	  mut root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;
	) -&gt; Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt; {
        let mut sum = 0;
        Self::h(&amp;mut root, &amp;mut sum);
        root
    }

    fn h(r: &amp;mut Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, sum: &amp;mut i32) {
        if let Some(r) = r {
            let mut r = r.borrow_mut();
            Self::h(&amp;mut r.right, sum);
            r.val += *sum;
            *sum = r.val;
            Self::h(&amp;mut r.left, sum);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#543diameter-of-binary-tree" id="543diameter-of-binary-tree">543.diameter-of-binary-tree</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn diameter_of_binary_tree(root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; i32 {
        let mut d = 1;
        Self::h(&amp;root, &amp;mut d);
        d - 1
    }

    fn h(r: &amp;Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, d: &amp;mut i32) -&gt; i32 {
        if let Some(r) = r {
            let r = r.borrow();
            let p = Self::h(&amp;r.left, d);
            let q = Self::h(&amp;r.right, d);
            *d = d.to_owned().max(p + q + 1);
            1 + p.max(q)
        } else {
            0
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#563binary-tree-tilt" id="563binary-tree-tilt">563.binary-tree-tilt</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn find_tilt(root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; i32 {
        let mut s = 0;
        Self::h(&amp;root, &amp;mut s);
        s
    }

    fn h(n: &amp;Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, s: &amp;mut i32) -&gt; i32 {
        if let Some(n) = n {
            let n = n.borrow();
            let l = Self::h(&amp;n.left, s);
            let r = Self::h(&amp;n.right, s);
            *s += (l - r).abs();
            n.val + l + r
        } else {
            0
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#572subtree-of-another-tree" id="572subtree-of-another-tree">572.subtree-of-another-tree</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn is_subtree(
	  s: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, 
	  t: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,
	) -&gt; bool {
        Self::h(&amp;s, &amp;t)
    }

    fn h(
	  s: &amp;Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, 
	  t: &amp;Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;
	) -&gt; bool {
        if s == t {
            return true;
        } else if s.is_none() {
            return false;
        }

        let s = s.as_ref().unwrap().borrow();
        Self::h(&amp;s.left, t) || Self::h(&amp;s.right, t)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#606construct-string-from-binary-tree" id="606construct-string-from-binary-tree">606.construct-string-from-binary-tree</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Solution {
    pub fn tree2str(t: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; String {
        Self::h(&amp;t)
    }

    fn h(t: &amp;Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; String {
        if let Some(t) = t {
            let t = t.borrow();
            let l = Self::h(&amp;t.left);
            let r = Self::h(&amp;t.right);
            let mut s = t.val.to_string();
            let f = match (l.is_empty(), r.is_empty()) {
                (true, true) =&gt; &quot;&quot;.to_string(),
                (false, true) =&gt; format!(&quot;({})&quot;, &amp;l),
                (true, false) =&gt; format!(&quot;()({})&quot;, &amp;r),
                (false, false) =&gt; format!(&quot;({})({})&quot;, &amp;l, &amp;r),
            };
            s += &amp;f;
            s
        } else {
            &quot;&quot;.to_string()
        }
    }
}
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
