<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js dark">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Round 1 - master-leetcode</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "dark";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('dark')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="../empty.html"><strong aria-hidden="true">1.</strong> C</a></li><li class="expanded "><a href="../empty.html"><strong aria-hidden="true">2.</strong> Java</a></li><li class="expanded "><a href="../empty.html"><strong aria-hidden="true">3.</strong> Koltin</a></li><li class="expanded "><a href="../empty.html"><strong aria-hidden="true">4.</strong> Python</a></li><li class="expanded "><a href="../empty.html"><strong aria-hidden="true">5.</strong> Rust</a></li><li><ol class="section"><li class="expanded "><a href="../rust/round_1.html" class="active"><strong aria-hidden="true">5.1.</strong> Round 1</a></li><li><ol class="section"><li class="expanded "><a href="../rust/round_1_linked_list.html"><strong aria-hidden="true">5.1.1.</strong> Linked-List</a></li><li class="expanded "><a href="../rust/round_1_tree.html"><strong aria-hidden="true">5.1.2.</strong> Tree</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">master-leetcode</h1>

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#round-1" id="round-1">Round 1</a></h1>
<h2><a class="header" href="#1-boxt-and-rc" id="1-boxt-and-rc">1. <code>Box&lt;T&gt;</code> and <code>Rc</code></a></h2>
<p><code>Box&lt;T&gt;</code>, casually referred to as a 'box', provides the simplest form of heap allocation in Rust. Boxes provide ownership for this allocation, and drop their contents when they go out of scope.</p>
<p><strong>What's the difference between <code>Rc&lt;T&gt;</code> and <code>Box&lt;T&gt;</code>?</strong></p>
<p><code>Rc</code> provides shared ownership so by default its contents can't be mutated, while <code>Box</code> provides exclusive ownership and thus mutation is allowed:</p>
<pre><pre class="playpen"><code class="language-rust">use std::rc::Rc;

fn main() {
    let mut a = Box::new(1);
    let mut b = Rc::new(1);

    *a = 2; // works
    *b = 2; // doesn't
}
</code></pre></pre>
<blockquote>
<p>Checkout this question on <a href="https://stackoverflow.com/questions/49377231/when-to-use-rc-vs-box">stackoverflow</a></p>
</blockquote>
<h2><a class="header" href="#2-cell-and-refcell" id="2-cell-and-refcell">2. <code>Cell</code> and <code>RefCell</code></a></h2>
<p>Values of the <code>Cell&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code> types may be mutated through shared references (i.e. the common &amp;T type), whereas most Rust types can only be mutated through unique <code>(&amp;mut T)</code> references. We say that <code>Cell&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code> provide <strong>'interior mutability'</strong>, in contrast with typical Rust types that exhibit <strong>'inherited mutability'</strong>.</p>
<p>Cell types come in two flavors: <code>Cell&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>. <code>Cell&lt;T&gt;</code> implements interior mutability by moving values in and out of the <code>Cell&lt;T&gt;</code>. To use references instead of values, one must use the <code>RefCell&lt;T&gt;</code> type, acquiring a write lock before mutating. <code>Cell&lt;T&gt;</code> provides methods to retrieve and change the current interior value:</p>
<ul>
<li>For types that implement <code>Copy</code>, the get method retrieves the current interior value.</li>
<li>For types that implement <code>Default</code>, the <code>take</code> method replaces the current interior value with <code>Default::default()</code> and returns the replaced value.</li>
<li>For all types, the <code>replace</code> method replaces the current interior value and returns the replaced value and the <code>into_inner</code> method consumes the <code>Cell&lt;T&gt;</code> and returns the interior value. Additionally, the <code>set</code> method replaces the interior value, dropping the replaced value.</li>
</ul>
<p><code>RefCell&lt;T&gt;</code> uses Rust's lifetimes to implement <code>'dynamic borrowing'</code>, a process whereby one can claim temporary, exclusive, mutable access to the inner value. Borrows for <code>RefCell&lt;T&gt;</code>s are tracked <code>'at runtime'</code>, unlike Rust's native reference types which are entirely tracked statically, at compile time. Because <code>RefCell&lt;T&gt;</code> borrows are dynamic it is possible to attempt to borrow a value that is already mutably borrowed; when this happens it results in thread panic.</p>
<h3><a class="header" href="#when-to-choose-interior-mutability" id="when-to-choose-interior-mutability">When to choose interior mutability?</a></h3>
<p>The more common inherited mutability, where one must have unique access to mutate a value, is one of the key language elements that enables Rust to reason strongly about pointer aliasing, statically preventing crash bugs. Because of that, inherited mutability is preferred, and interior mutability is something of a last resort. Since cell types enable mutation where it would otherwise be disallowed though, there are occasions when interior mutability might be appropriate, or even must be used, e.g.</p>
<ul>
<li>Introducing mutability 'inside' of something immutable</li>
<li>Implementation details of logically-immutable methods.</li>
<li>Mutating implementations of <code>Clone</code>.</li>
</ul>
<h2><a class="header" href="#3-asref-and-borrow" id="3-asref-and-borrow">3. <code>AsRef</code> and <code>Borrow</code></a></h2>
<p><code>AsRef</code> is similar to <code>AsMut</code> which is used for converting between mutable references. If you need to do a costly conversion it is better to implement From with type &amp;T or write a custom function.</p>
<p><strong>AsRef has the same signature as Borrow, but Borrow is different in few aspects:</strong></p>
<ul>
<li>
<p>Unlike AsRef, Borrow has a blanket impl for any T, and can be used to accept either a reference or a value.</p>
</li>
<li>
<p>Borrow also requires that Hash, Eq and Ord for borrowed value are equivalent to those of the owned value. For this reason, if you want to borrow only a single field of a struct you can implement AsRef, but not Borrow.</p>
</li>
</ul>
<p>Note: This trait must not fail. If the conversion can fail, use a dedicated method which returns an Option<T> or a Result&lt;T, E&gt;.</p>
<h3><a class="header" href="#example" id="example">Example</a></h3>
<p>By creating a generic function that takes an <code>AsRef&lt;str&gt;</code> we express that we want to accept all references that can be converted to <code>&amp;str</code> as an argument. Since both String and <code>&amp;str</code> implement <code>AsRef&lt;str&gt;</code> we can accept both as input argument.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn is_hello&lt;T: AsRef&lt;str&gt;&gt;(s: T) {
   assert_eq!(&quot;hello&quot;, s.as_ref());
}

let s = &quot;hello&quot;;
is_hello(s);

let s = &quot;hello&quot;.to_string();
is_hello(s);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#4-clonecopy-and-toowned" id="4-clonecopy-and-toowned">4. <code>Clone</code>、<code>Copy</code> and <code>ToOwned</code></a></h2>
<p>Differs from <code>Copy</code> in that <code>Copy</code> is implicit and extremely inexpensive, while Clone is always explicit and may or may not be expensive. In order to enforce these characteristics, Rust does not allow you to reimplement Copy, but you may reimplement Clone and run arbitrary code.</p>
<p><code>Copy</code> are the types whose values can be duplicated simply by copying bits:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// We can derive a `Copy` implementation. `Clone` is also required, as it's
// a supertrait of `Copy`.
#[derive(Debug, Copy, Clone)]
struct Foo;

let x = Foo;

let y = x;

// `y` is a copy of `x`

println!(&quot;{:?}&quot;, x); // A-OK!
<span class="boring">}
</span></code></pre></pre>
<p>Both a copy and a move can result in bits being copied in memory, although this is sometimes optimized away.</p>
<p><code>Clone</code> is a supertrait of <code>Copy</code>, so everything which is <code>Copy</code> must also implement <code>Clone</code>. If a type is <code>Copy</code> then its <code>Clone</code> implementation only needs to return *self (see the example above).</p>
<p><code>ToOnwed</code> are some types make it possible to go from borrowed to owned, usually by implementing the Clone trait. But Clone works only for going from &amp;T to T. The ToOwned trait generalizes Clone to construct owned data from any borrow of a given type.</p>
<h2><a class="header" href="#5-zero-copy" id="5-zero-copy">5. Zero Copy</a></h2>
<h3><a class="header" href="#stdmemswap" id="stdmemswap"><code>std::mem::swap</code></a></h3>
<p>Swaps the values at two mutable locations, without deinitializing either one.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::mem;

let mut x = 5;
let mut y = 42;

mem::swap(&amp;mut x, &amp;mut y);

assert_eq!(42, x);
assert_eq!(5, y);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#stdmemreplace" id="stdmemreplace"><code>std::mem::replace</code></a></h3>
<p>Moves src into the referenced dest, returning the previous dest value.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::mem;

let mut v: Vec&lt;i32&gt; = vec![1, 2];

let old_v = mem::replace(&amp;mut v, vec![3, 4, 5]);
assert_eq!(vec![1, 2], old_v);
assert_eq!(vec![3, 4, 5], v);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#stdoptionoptiontake" id="stdoptionoptiontake"><code>std::option::Option::take</code></a></h3>
<p>Takes the value out of the option, leaving a None in its place.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut x = Some(2);
let y = x.take();
assert_eq!(x, None);
assert_eq!(y, Some(2));

let mut x: Option&lt;u32&gt; = None;
let y = x.take();
assert_eq!(x, None);
assert_eq!(y, None);
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../empty.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../rust/round_1_linked_list.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../empty.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../rust/round_1_linked_list.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
